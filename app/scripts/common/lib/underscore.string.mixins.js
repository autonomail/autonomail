/**
 * underscore.string mixins.
 */

(function(ns) {
  var EMAIL_REGEX = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}/ig;

  /**
   * Generate a unique id.
   *
   * Strings generated by this method are NOT cryptographically safe.
   *
   * @return {String} 16-character string.
   */
  ns.id = function() {
    return ns.gen(1, 16).pop();
  };



  /**
   * Generate random hex strings.
   *
   * Strings generated by this method are NOT cryptographically safe.
   *
   * @param num {Integer} no. of strings to generate.
   * @param len {Integer} no. of characters each string should have.
   *
   * @return {Array}
   */
  ns.gen = function(num, len) {
    var ret = [];
    var possible = "abcdef0123456789";

    for (var i=0; i<num; ++i) {
      var text = "";
      for( var j=0; j < len; j++ ) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
      }
      ret.push(text);
    }

    return ret;
  };


  /**
   * Extract email addresses from given string.
   *
   * This method uses a Regex to extract strings, allowing it to 
   * handle cases where other strings (e.g. person names) are interleaved with 
   * the addresses.
   *
   * @param {String} str The email address string.
   * 
   * @return {Array} The list of email addresses matched.
   */
  ns.extractEmailAddresses = function(str) {
    return _.chain(str.match(EMAIL_REGEX))
      .map(ns.sanitizeEmailAddress)
      .uniq()
      .value();
  };


  /**
   * Extract names and email addresses from given string.
   *
   * This assumes that multiple name + email combinations are separated by a 
   * comma.
   *
   * @param {String} str The email address string.
   * 
   * @return {Array} where each item is an `Object` containing the person's 
   * name (if available) and email address.
   */
  ns.extractNamesAndEmailAddresses = function(str) {
    var tokens = str.split(',');

    var ret = [];

    _.each(tokens, function(token) {
      var nxt = {};

      // must contain valid email address
      var matchedAddresses = token.match(EMAIL_REGEX);
      if (!matchedAddresses || 1 !== matchedAddresses.length) {
        return;
      }

      var po = token.indexOf('<');
      if (0 < po) {
        nxt.name = _.str.trim(token.substr(0, po));
        nxt.email = _.str.trim(token.substr(po + 1), ' >');
      } else {
        nxt.name = null;
        nxt.email = _.str.trim(token);
      }

      nxt.email = ns.sanitizeEmailAddress(nxt.email);      

      ret.push(nxt);        
    });

    return _.uniq(ret, 'email');
  };


  /**
   * Sanitize given email address.
   *
   * This will ensure the domain part of the address is lowercase.
   *
   * @param {String} email The email address.
   * @return {String}
   */
  ns.sanitizeEmailAddress = function(email) {
    var emailTokens = email.split('@');
    return emailTokens[0] + '@' + emailTokens[1].toLowerCase();
  };

}(_.str));

